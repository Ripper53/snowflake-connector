use heck::{ToSnakeCase, ToUpperCamelCase};
use quote::quote;
use std::{
    collections::{HashMap, hash_map::Entry},
    io::{BufRead, Read, Seek, Write},
};

#[tokio::main]
async fn main() {
    println!("cargo:rerun-if-changed=NULL");
    if std::env::var("PROFILE").unwrap() == "release" {
        return;
    }

    let snowflake_path = std::env::var("SNOWFLAKE_PATH")
        .expect("Failed to find SNOWFLAKE_PATH environment variable");
    let info_path = std::path::Path::new(&snowflake_path).join("snowflake_config.toml");
    let mut config_file = std::fs::OpenOptions::new()
        .read(true)
        .open(info_path)
        .expect("Failed reading `snowflake_config.toml` file");
    let mut s = String::new();
    {
        let last_modified = config_file
            .metadata()
            .expect("Failed to fetch metadata")
            .modified()
            .expect("Failed to get modified time")
            .duration_since(std::time::UNIX_EPOCH)
            .expect("Failed to get epoch")
            .as_secs() as usize;
        let cache_path =
            std::path::Path::new(&std::env::var("OUT_DIR").unwrap()).join("snowflake_cache.toml");
        let mut cache_file = std::fs::OpenOptions::new()
            .read(true)
            .write(true)
            .create(true)
            .open(cache_path)
            .expect("Failed to create `snowflake_cache.toml` file");
        cache_file.read_to_string(&mut s);
        let mut write_cache_file = |snowflake_data: SnowflakeData| {
            cache_file.set_len(0).unwrap();
            cache_file.seek(std::io::SeekFrom::Start(0)).unwrap();
            cache_file
                .write_all(
                    format!(
                        "# Auto-generated by `snowflake-connector`\n{}",
                        toml::to_string(&snowflake_data).unwrap()
                    )
                    .as_bytes(),
                )
                .unwrap();
        };
        if s.is_empty() {
            let snowflake_data = SnowflakeData { last_modified };
            write_cache_file(snowflake_data);
        } else {
            let snowflake_data: SnowflakeData = toml::from_str(&s).unwrap();
            if snowflake_data.last_modified == last_modified {
                // Cached.
                return;
            } else {
                write_cache_file(snowflake_data);
            }
        }
    }

    s.clear();
    config_file.read_to_string(&mut s);
    let file: FileContent = toml::de::from_str(&s).unwrap();
    let connector = snowflake_deserializer::SnowflakeConnector::try_new_from_file(
        &file.public_key_path,
        &file.private_key_path,
        &file.host,
        &file.account,
        &file.user,
    )
    .unwrap();
    // (namespace, structs (tables))
    let mut structs = HashMap::<proc_macro2::Ident, Vec<proc_macro2::TokenStream>>::new();
    for database in file.databases {
        for table in database.tables {
            let table_name = table.name;
            let sql = format!("SELECT * FROM {table_name} LIMIT 0");
            let mut sql = connector.execute(&database.name).sql(&sql);
            if let Some(ref role) = file.role {
                sql = sql.with_role(role);
            }
            if let Some(ref warehouse) = file.warehouse {
                sql = sql.with_warehouse(warehouse);
            }
            let value = sql.text().await.unwrap();
            let value: serde_json::Value =
                serde_json::from_str(&value).expect("Failed to parse Snowflake result");
            let metadata = value
                .get("resultSetMetaData")
                .expect(&format!("Could not find metadata in response: {}", value));
            let row_types = metadata
                .get("rowType")
                .unwrap()
                .as_array()
                .expect("Failed to find `rowType`");
            let mut names = Vec::with_capacity(row_types.len());
            let mut attributes = Vec::with_capacity(row_types.len());
            let mut types = Vec::with_capacity(row_types.len());
            let mut tables = Vec::new();
            let mut databases = HashMap::new();
            let mut enums = Vec::new();
            for row_type in row_types {
                let name = row_type
                    .get("name")
                    .unwrap()
                    .as_str()
                    .unwrap()
                    .to_snake_case();
                names.push(syn::Ident::new(&name, proc_macro2::Span::call_site()));
                let nullable = row_type.get("nullable").unwrap().as_bool().unwrap();
                let ty = row_type.get("type").unwrap().as_str().unwrap();
                let ty = match ty {
                    "boolean" => quote!(bool),
                    "binary" => quote!(::std::string::String),
                    "fixed" => {
                        let scale = row_type.get("scale").unwrap().as_u64().unwrap();
                        if scale == 0 {
                            if table.unsigned.contains(&name) {
                                quote!(usize)
                            } else {
                                quote!(isize)
                            }
                        } else {
                            quote!(f64)
                        }
                    }
                    "real" => {
                        quote!(f64)
                    }
                    "text" | "variant" => {
                        if let Some(value) = table.enums.get(&name) {
                            let name = proc_macro2::Ident::new(
                                &name.to_upper_camel_case(),
                                proc_macro2::Span::call_site(),
                            );
                            quote!(#name)
                        } else if let Some(value) = table.json_rows.get(&name) {
                            attributes.push(quote!(#[snowflake(json)]));
                            if value == "--auto" {
                                todo!("AUTOMATICALLY FIGURE OUT JSON TYPE");
                            } else {
                                let value: syn::Path = syn::parse_str(value).expect(&format!(
                                    "Failed to parse path for custom value: {}",
                                    value
                                ));
                                quote!(#value)
                            }
                        } else {
                            quote!(::std::string::String)
                        }
                    }
                    "date" => quote!(::snowflake_connector::chrono::NaiveDate),
                    "time" => quote!(::snowflake_connector::chrono::NaiveTime),
                    "timestamp_ntz" => quote!(::snowflake_connector::chrono::NaiveDateTime),
                    "timestamp_ltz" => quote!(
                        ::snowflake_connector::chrono::DateTime<::snowflake_connector::chrono::Utc>
                    ),
                    "timestamp_tz" => {
                        quote!(
                            ::snowflake_connector::chrono::DateTime<
                                ::snowflake_connector::chrono::FixedOffset,
                            >
                        )
                    }
                    unknown_type => panic!("unhandled unknown type: {unknown_type}"),
                };
                if nullable {
                    types.push(quote!(::std::option::Option<#ty>));
                } else {
                    types.push(ty);
                }
                let table = row_type
                    .get("table")
                    .unwrap()
                    .as_str()
                    .unwrap()
                    .to_upper_camel_case();
                tables.push(syn::Ident::new(&table, proc_macro2::Span::call_site()));
                let database = row_type
                    .get("database")
                    .unwrap()
                    .as_str()
                    .unwrap()
                    .to_snake_case();
                databases.insert(
                    table,
                    syn::Ident::new(&database, proc_macro2::Span::call_site()),
                );
                if names.len() != attributes.len() {
                    attributes.push(proc_macro2::TokenStream::new());
                }
            }
            for (enum_name, str_variants) in table.enums {
                let enum_name = proc_macro2::Ident::new(
                    &enum_name.to_upper_camel_case(),
                    proc_macro2::Span::call_site(),
                );
                let variants = str_variants
                    .iter()
                    .map(|variant| {
                        proc_macro2::Ident::new(
                            &variant.to_upper_camel_case(),
                            proc_macro2::Span::call_site(),
                        )
                    })
                    .collect::<Vec<_>>();
                let enum_error = proc_macro2::Ident::new(
                    &format!("{}ParseError", enum_name),
                    proc_macro2::Span::call_site(),
                );
                let enum_name_str =
                    syn::LitStr::new(&enum_name.to_string(), proc_macro2::Span::call_site());
                enums.push(quote! {
                    #[derive(Hash, PartialEq, Eq, Clone, Copy, Debug)]
                    pub enum #enum_name {
                        #(#variants,)*
                    }
                    impl ::snowflake_connector::DeserializeFromStr for #enum_name {
                        type Error = #enum_error;
                        fn deserialize_from_str(value: &str) -> Result<Self, Self::Error>
                            where
                                Self: Sized {
                            match value {
                                #(
                                    #str_variants => Ok(Self::#variants),
                                )*
                                unknown_value => Err(#enum_error { unknown_value: unknown_value.to_string() }),
                            }
                        }
                    }
                    #[derive(Debug)]
                    pub struct #enum_error {
                        pub unknown_value: String,
                    }
                    impl ::std::fmt::Display for #enum_error {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                            write!(f, "error parsing `{}` unknown value: {}", #enum_name_str, self.unknown_value)
                        }
                    }
                    impl ::std::error::Error for #enum_error {}
                });
            }
            tables.dedup();
            if tables.is_empty() {
                panic!("No tables found for query");
            } else if tables.len() == 1 {
                let table = tables.pop().unwrap();
                let database = databases.remove(&table.to_string()).unwrap();
                let code = quote! {
                    /// Auto-generated table from `snowflake-connector`
                    #[derive(::snowflake_connector::SnowflakeDeserialize, Debug)]
                    pub struct #table {
                        #(
                            #attributes
                            pub #names: #types,
                        )*
                    }
                    #(#enums)*
                };
                match structs.entry(database) {
                    Entry::Occupied(o) => {
                        o.into_mut().push(code);
                    }
                    Entry::Vacant(v) => {
                        v.insert(vec![code]);
                    }
                }
            } else {
                todo!("Unhandled multiple table query! Amount: {}", tables.len());
            }
        }
    }
    let mut generated_code = Vec::with_capacity(structs.len());
    for (database, tables) in structs {
        generated_code.push(quote! {
            pub mod #database {
                #(#tables)*
            }
        });
    }

    let output_path = std::path::Path::new(&snowflake_path).join("snowflake_tables.rs");
    let mut file = std::fs::OpenOptions::new()
        .truncate(true)
        .write(true)
        .create(true)
        .open(&output_path)
        .expect("Failed to create/open `snowflake_table.rs` file");
    let generated = quote! {
        #(
            #generated_code
        )*
    }
    .to_string();
    file.write_all(generated.as_bytes());
}

#[derive(serde::Deserialize, Debug)]
struct FileContent {
    private_key_path: String,
    public_key_path: String,
    host: String,
    account: String,
    user: String,
    role: Option<String>,
    warehouse: Option<String>,
    databases: Vec<Database>,
}

#[derive(serde::Deserialize, Debug)]
struct Database {
    name: String,
    tables: Vec<Table>,
}

#[derive(serde::Deserialize, Debug)]
struct Table {
    name: String,
    #[serde(rename = "json")]
    #[serde(default)]
    json_rows: HashMap<String, String>,
    #[serde(default)]
    unsigned: Vec<String>,
    #[serde(default)]
    enums: HashMap<String, Vec<String>>,
}

/*#[derive(serde::Deserialize, Debug)]
pub struct JsonMap {
    #[serde(rename = "name")]
    row_name: String,
    #[serde(rename = "type")]
    type_name: String,
}*/

#[derive(serde::Serialize, serde::Deserialize, Debug)]
struct SnowflakeData {
    last_modified: usize,
}
